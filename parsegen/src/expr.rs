// This file is autogenerated
/*graph: 
        digraph {
  node [shape=circle];
  Q1 [style=invisible, height=0, width=0, fixedsize=true];
  node_type = "usize";
  item_type = "(core::option::Option<(usize, bool)>, core::option::Option<parsegen::tokenizer::Token>)";
  kind = nfa;
  Q1 -> "1";
0 -> 1 [label="Add"];
1 -> 2 [label="Factor(1"];
4 -> 0 [label=")1"];
2 -> 3 [label="Mul"];
3 -> 6 [label="Lp(2"];
3 -> 4 [label="Ident(2"];
3 -> 4 [label="Number(2"];
8 -> 2 [label=")2"];
5 -> 6 [label="Lp"];
5 -> 4 [label="Ident"];
5 -> 4 [label="Number"];
6 -> 0 [label="Term(3"];
0 -> 7 [label=")3"];
7 -> 4 [label="Rp"];
  "0" [shape=doublecircle];
}

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Token {
Add,
Mul,
Lp,
Ident,
Number,
Rp,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Node {
ExprStart,
ExprEnd,
TermStart,
TermEnd,
FactorStart,
FactorEnd,
Add(usize),
Mul(usize),
Lp(usize),
Ident(usize),
Number(usize),
Rp(usize),
} use std::fmt::Display; impl Display for Token { fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { match self { Self::Add => write!(fmt, "Add"),
Self::Mul => write!(fmt, "Mul"),
Self::Lp => write!(fmt, "Lp"),
Self::Ident => write!(fmt, "Ident"),
Self::Number => write!(fmt, "Number"),
Self::Rp => write!(fmt, "Rp"),
} } }
 impl Display for Node { fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { match self { Self::Add(i) => write!(fmt, "Add({i})"),
Self::Mul(i) => write!(fmt, "Mul({i})"),
Self::Lp(i) => write!(fmt, "Lp({i})"),
Self::Ident(i) => write!(fmt, "Ident({i})"),
Self::Number(i) => write!(fmt, "Number({i})"),
Self::Rp(i) => write!(fmt, "Rp({i})"),
Self::ExprStart => write!(fmt, "ExprStart"),
Self::ExprEnd=> write!(fmt, "ExprEnd"),
Self::TermStart => write!(fmt, "TermStart"),
Self::TermEnd=> write!(fmt, "TermEnd"),
Self::FactorStart => write!(fmt, "FactorStart"),
Self::FactorEnd=> write!(fmt, "FactorEnd"),
} } }

#[derive(Debug, Clone, PartialEq)]
pub struct Parser {
    state: usize,
    brackets: Vec<usize>,
    tokens_eaten: usize,
}

impl Parser {
    pub fn new() -> Self {
        Self { state: 1, brackets: vec![0], tokens_eaten: 0 }
    }

    fn top_bracket(&self) -> usize { self.brackets.last().cloned().unwrap() }

    pub fn eat_token(&mut self, tok: Token) -> Vec<Node> {
        let top = self.top_bracket();
        let mut res = vec![];
        let mut consumed = false;
        while !consumed {
        match self.state {
            0 if tok == Token::Add => { res.push(Node::Add(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; self.state = 1; }
0 if top == 3 => { self.brackets.pop(); self.state = 7; }
1 if tok == Token::Factor => { self.brackets.push(1);res.push(Node::ExprStart); res.push(Node::Factor(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::TermEnd); self.state = 2; }
2 if tok == Token::Mul => { res.push(Node::Mul(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; self.state = 3; }
3 if tok == Token::Lp => { self.brackets.push(2);res.push(Node::TermStart); res.push(Node::Lp(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; self.state = 6; }
3 if tok == Token::Ident => { self.brackets.push(2);res.push(Node::TermStart); res.push(Node::Ident(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::FactorEnd); self.state = 4; }
3 if tok == Token::Number => { self.brackets.push(2);res.push(Node::TermStart); res.push(Node::Number(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::FactorEnd); self.state = 4; }
4 if top == 1 => { self.brackets.pop(); res.push(Node::ExprEnd); self.state = 0; }
5 if tok == Token::Lp => { res.push(Node::FactorStart); res.push(Node::Lp(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; self.state = 6; }
5 if tok == Token::Ident => { res.push(Node::FactorStart); res.push(Node::Ident(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::FactorEnd); self.state = 4; }
5 if tok == Token::Number => { res.push(Node::FactorStart); res.push(Node::Number(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::FactorEnd); self.state = 4; }
6 if tok == Token::Term => { self.brackets.push(3);res.push(Node::Term(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::ExprEnd); self.state = 0; }
7 if tok == Token::Rp => { res.push(Node::Rp(self.tokens_eaten)); self.tokens_eaten += 1; consumed = true; res.push(Node::FactorEnd); self.state = 4; }
8 if top == 2 => { self.brackets.pop(); res.push(Node::TermEnd); self.state = 2; }

            _ => panic!("Could not continue on {}, {top}, {tok}!", self.state) 
        } }
    return res;
    }

    pub fn is_in_end_state(&self) -> bool {
        if self.brackets.len() != 1 || self.brackets[0] != 0 { return false; }
        match self.state {
0 => true,
_ => false, } } }
